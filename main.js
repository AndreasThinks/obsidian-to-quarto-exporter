/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => ObsidianToQuartoPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  dateOption: "none",
  dateFormat: "YYYY-MM-DD",
  outputFolder: "",
  overwriteExisting: false,
  importTags: true
};
var ObsidianToQuartoPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading ObsidianToQuartoPlugin");
    await this.loadSettings();
    this.addCommand({
      id: "export-to-quarto",
      name: "Export to Quarto QMD",
      callback: () => this.exportToQuarto()
    });
    this.addSettingTab(new ObsidianToQuartoSettingTab(this.app, this));
    console.log("ObsidianToQuartoPlugin loaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async exportToQuarto() {
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || activeFile.extension !== "md") {
        new import_obsidian.Notice("Please open a Markdown file before exporting");
        return;
      }
      const content = await this.app.vault.read(activeFile);
      const convertedContent = await this.convertToQuarto(content, activeFile);
      const outputFolder = this.settings.outputFolder || activeFile.parent.path;
      let newFileName = activeFile.basename + ".qmd";
      let newPath = `${outputFolder}/${newFileName}`;
      await this.app.vault.adapter.mkdir(outputFolder);
      if (await this.app.vault.adapter.exists(newPath)) {
        if (this.settings.overwriteExisting) {
          await this.app.vault.adapter.remove(newPath);
        } else {
          let counter = 1;
          while (await this.app.vault.adapter.exists(newPath)) {
            newFileName = `${activeFile.basename}_${counter}.qmd`;
            newPath = `${outputFolder}/${newFileName}`;
            counter++;
          }
        }
      }
      await this.app.vault.create(newPath, convertedContent);
      const newFile = this.app.vault.getAbstractFileByPath(newPath);
      if (newFile instanceof import_obsidian.TFile) {
        await this.app.workspace.openLinkText(newFile.path, "", true);
      }
      new import_obsidian.Notice(`Successfully exported to ${newFileName}`);
    } catch (error) {
      console.error("Error in exportToQuarto:", error);
      new import_obsidian.Notice("Failed to export to Quarto QMD. Check console for details.");
    }
  }
  async convertToQuarto(content, file) {
    let convertedContent = content;
    const title = file.basename;
    let frontmatter = `---
title: "${title}"
`;
    if (this.settings.dateOption !== "none") {
      const date = await this.getFileDate(file);
      frontmatter += `date: "${date}"
`;
    }
    if (this.settings.importTags) {
      const fileTags = this.getFileTags(file);
      if (fileTags.length > 0) {
        frontmatter += `tags: [${fileTags.map((tag) => `"${tag}"`).join(", ")}]
`;
      }
    }
    frontmatter += "---\n\n";
    if (/^---\n/.test(convertedContent)) {
      convertedContent = convertedContent.replace(/^---\n[\s\S]*?---\n/, frontmatter);
    } else {
      convertedContent = frontmatter + convertedContent;
    }
    convertedContent = await this.convertEmbeddedNotes(convertedContent);
    convertedContent = convertedContent.replace(/^(#+\s.*)/gm, "\n$1");
    convertedContent = convertedContent.replace(/> \[!(\w+)\](.*?)\n((?:>.*\n?)*)/g, (_, type, title2, content2) => {
      const quartoType = this.mapCalloutType(type);
      return `::: {.callout-${quartoType}}
${title2.trim() ? `## ${title2.trim()}
` : ""}${content2.replace(/^>/gm, "").trim()}
:::

`;
    });
    return convertedContent;
  }
  getFileTags(file) {
    var _a;
    const fileCache = this.app.metadataCache.getFileCache(file);
    const tags = [];
    if (fileCache == null ? void 0 : fileCache.tags) {
      tags.push(...fileCache.tags.map((t) => t.tag.replace("#", "")));
    }
    if ((_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a.tags) {
      if (Array.isArray(fileCache.frontmatter.tags)) {
        tags.push(...fileCache.frontmatter.tags);
      } else if (typeof fileCache.frontmatter.tags === "string") {
        tags.push(fileCache.frontmatter.tags);
      }
    }
    return [...new Set(tags)];
  }
  async getFileDate(file) {
    try {
      const stat = await this.app.vault.adapter.stat(file.path);
      if (!stat) {
        console.error("Failed to get file stats");
        return this.formatDate(new Date());
      }
      const date = this.settings.dateOption === "created" ? stat.ctime : stat.mtime;
      return this.formatDate(new Date(date));
    } catch (error) {
      console.error("Error getting file date:", error);
      return this.formatDate(new Date());
    }
  }
  formatDate(date) {
    const format = this.settings.dateFormat;
    return format.replace("YYYY", date.getFullYear().toString()).replace("MM", (date.getMonth() + 1).toString().padStart(2, "0")).replace("DD", date.getDate().toString().padStart(2, "0")).replace("HH", date.getHours().toString().padStart(2, "0")).replace("mm", date.getMinutes().toString().padStart(2, "0")).replace("ss", date.getSeconds().toString().padStart(2, "0"));
  }
  async convertEmbeddedNotes(content) {
    const embeddedNoteRegex = /!\[\[([^\]]+)\]\]/g;
    const embedPromises = [];
    content.replace(embeddedNoteRegex, (match, noteName) => {
      embedPromises.push(this.getEmbeddedNoteContent(noteName));
      return match;
    });
    const embeddedContents = await Promise.all(embedPromises);
    return content.replace(embeddedNoteRegex, () => embeddedContents.shift() || "");
  }
  async getEmbeddedNoteContent(noteName) {
    const file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
    if (file instanceof import_obsidian.TFile) {
      const content = await this.app.vault.read(file);
      return `

## Embedded note: ${noteName}

${content}

`;
    } else {
      return `

> [!warning] Embedded note not found: ${noteName}

`;
    }
  }
  mapCalloutType(obsidianType) {
    const typeMap = {
      "note": "note",
      "info": "info",
      "tip": "tip",
      "success": "success",
      "question": "question",
      "warning": "warning",
      "failure": "error",
      "danger": "warning",
      "bug": "bug",
      "example": "example",
      "quote": "quote"
    };
    return typeMap[obsidianType.toLowerCase()] || "note";
  }
  slugify(text) {
    return text.toLowerCase().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
  }
};
var ObsidianToQuartoSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Date Option").setDesc("Choose which date to add to the Quarto document").addDropdown((dropdown) => dropdown.addOption("none", "No date").addOption("created", "Creation date").addOption("modified", "Last modified date").setValue(this.plugin.settings.dateOption).onChange(async (value) => {
      this.plugin.settings.dateOption = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date Format").setDesc("Specify the date format (YYYY: year, MM: month, DD: day, HH: hour, mm: minute, ss: second)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Output Folder").setDesc("Specify the folder where QMD files should be saved (leave blank to use the same folder as the original file)").addText((text) => text.setPlaceholder("Enter folder path").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
      this.plugin.settings.outputFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Overwrite Existing Files").setDesc("If checked, existing files will be overwritten. If unchecked, a new file with a number appended will be created.").addToggle((toggle) => toggle.setValue(this.plugin.settings.overwriteExisting).onChange(async (value) => {
      this.plugin.settings.overwriteExisting = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Import Tags").setDesc("If checked, tags from the Obsidian note will be imported into the Quarto file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.importTags).onChange(async (value) => {
      this.plugin.settings.importTags = value;
      await this.plugin.saveSettings();
    }));
  }
};
